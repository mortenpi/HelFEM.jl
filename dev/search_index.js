var documenterSearchIndex = {"docs":
[{"location":"polynomial/#Polynomial-bases","page":"Polynomial bases","title":"Polynomial bases","text":"","category":"section"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"The HelFEM.PolynomialBasis type wraps the corresponding C++ class and defines a primitive polynomial basis â€“- a set of polynomials p_i(x) on the domain x in -1 1. In the finite element method, these are then repeated in each element.","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"Currently the library supports three types of polynomials:","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":":legendre: Legendre polynomials\n:hermite: Hermite polynomials\n:lip: Lagrange interpolating polynomials (with Gauss-Lobatto nodes)","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"Each primitive basis is defined by the number of nodes, which then determines the order of the polynomials and how many polynomials are there in the set.","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"using HelFEM, Plots\nxs = range(-1, 1, length=2001)\na = @animate for nnodes = 2:15\n    b1 = PolynomialBasis(:legendre, nnodes)\n    b2 = PolynomialBasis(:hermite, nnodes)\n    b3 = PolynomialBasis(:lip, nnodes)\n    plot(\n        plot(xs, b1(xs), label=false, title=\"Legendre, nnodes=$nnodes\"),\n        plot(xs, b2(xs), label=false, title=\"Hermite, nnodes=$nnodes\"),\n        plot(xs, b3(xs), label=false, title=\"LIP, nnodes=$nnodes\"),\n        layout = (3, 1), size=(800, 1000)\n    )\nend\ngif(a, fps=0.5)","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"Various methods are available to work with the polynomial basis and for introspection (see the reference).","category":"page"},{"location":"polynomial/#Reference","page":"Polynomial bases","title":"Reference","text":"","category":"section"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"PolynomialBasis\nlength(::PolynomialBasis)\nHelFEM.nnodes(::PolynomialBasis)","category":"page"},{"location":"polynomial/#HelFEM.PolynomialBasis","page":"Polynomial bases","title":"HelFEM.PolynomialBasis","text":"struct PolynomialBasis\n\nWrapper type for the helfem::atomic::polynomial_basis::PolynomialBasis class, representing a set of polynomials p_i(x) on a domain x in -1 1.\n\nConstructors\n\nPolynomialBasis(basis::Symbol, nnodes)\n\nConstructs a particular polynomial basis with a specific number of defining nodes. basis must be one of: :hermite, :legendre or :lip.\n\n\n\n\n\n","category":"type"},{"location":"polynomial/#Base.length-Tuple{PolynomialBasis}","page":"Polynomial bases","title":"Base.length","text":"length(pb::PolynomialBasis) -> Integer\n\nReturns the number of basis functions (polynomials) represented by the given polynomial basis.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#HelFEM.nnodes-Tuple{PolynomialBasis}","page":"Polynomial bases","title":"HelFEM.nnodes","text":"HelFEM.nnodes(pb::PolynomialBasis) -> Integer\n\nReturns the number of control nodes used to define the polynomial basis in the constructor.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#Finite-element-basis","page":"FEM basis","title":"Finite element basis","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The FEMBasis type provides an alternative implementation of the finite element basis with slightly different conventions. Unlike RadialBasis, it does not scale the elements with 1r, so it can also span into negative x values.","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"It is also implemented directly in Julia, rather than wrapping a C++ class, although it still relies on the primitive polynomial bases from the HelFEM C++ library.)","category":"page"},{"location":"fembasis/#Elements,-polynomials-and-basis-functions","page":"FEM basis","title":"Elements, polynomials and basis functions","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The basis is defined as a set of polynomials (p_i(t); an instance of PolynomialBasis) that is repeated in each element. The elements are simply defined as a list of N+1 real values x_1  x_2  ldots  x_N+1.","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"Each polynomial is defined on the domain t in -1 1 and so for each element where x in x_i x_i+1, the transformation between the two coordinates is given by","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"x = x^(k)_rmmid + x^(k)_rmlambda t\niff\nt = fracx - x^(k)_rmmidx^(k)_rmlambda","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"where x^(k)_rmmid and x^(k)_rmlambda are the midpoint and width of the k-th element, respecively, defined by","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"x^(k)_rmmid = fracx_i+1 + x_i2\nquad\nx^(k)_rmlambda = fracx_i+1 - x_i2","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The basis functions b_i(x) are therefore just the original polynomials scaled to each element using that transformation. The only exception to that are the first and last polynomial in each element that are formally joined together into a single basis function that spans two elements. By definition, outside of the range x_1 x_N+1, the basis functions are assumed to be zero.","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The basis also drops the first polynomial in the first elements and the last polynomial in the last elements to impose the boundary conditions","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"b_i(x_1) = 0 quad b_i(x_N) = 0","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"using HelFEM, Plots\npb = PolynomialBasis(:lip, 4)\nxgrid = [-2, -0.5, 1.5, 3]\nb = FEMBasis(pb, xgrid)\n# Calculate points for plotting\nrs = range(minimum(xgrid), maximum(xgrid), length=501)\nbs = b(rs)\na = @animate for i in 1:length(b)\n    plot(size=(900, 350), legend=false, ylabel = [raw\"$b(r)$\" raw\"$r~b(r)$\"])\n    plot!(rs, bs, c=:lightgray)\n    plot!(rs, bs[:,i], c=:black)\n    vline!([xgrid xgrid], ls=:dash, c=1)\nend\ngif(a, fps=1)","category":"page"},{"location":"fembasis/#Matrix-elements","page":"FEM basis","title":"Matrix elements","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The radial_integral method can be used to evaluate matrix elements of a function f(x) between the basis functions (or its derivatives)","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"f^(nm)_ij = int_x_1^x_N+1 b^(n)*_i(x) f(x) b^(m)_j(x)  dx","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"By default, the basis functions themselves are used (n = m = 0), but optionally it is also possible to substitute them with derivatives (i.e. n = 1 and/or m=1).","category":"page"},{"location":"fembasis/#Reference","page":"FEM basis","title":"Reference","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"FEMBasis\nFEMBasis(::Any) # corresponds to (::FEMBasis)(::Any)\nlength(::FEMBasis)\nboundaries(::FEMBasis)\nnelements(::FEMBasis)\nradial_integral(::FEMBasis, ::Any)","category":"page"},{"location":"fembasis/#HelFEM.FEMBasis","page":"FEM basis","title":"HelFEM.FEMBasis","text":"struct FEMBasis\n\nProvides a Julia-based implementation of a finite element basis, but using HelFEM-provided primitive polynomials. Unlike RadialBasis, it does not scale the basis functions with 1r, and is therefore valid for any x interval on mathbbR.\n\nConstructors\n\nFEMBasis(pb::PolynomialBasis, boundaries; [nquad])\n\nConstructs a FEM basis with elements defined by the boundaries specified by boundaries using the set of polynomials defined by pb as the primitive polynomials basis. Optionally, nquad can be specified to change the number of quadrature points used in the Gauss-Chebyshev quadrature when evaluating matrix elements.\n\n\n\n\n\n","category":"type"},{"location":"fembasis/#HelFEM.FEMBasis-Tuple{Any}","page":"FEM basis","title":"HelFEM.FEMBasis","text":"(b::FEMBasis)(qs; derivative=0) -> Matrix\n\nFunctor syntax to evaluate the basis functions at specified points. Returns a matrix where each column corresponds to a basis function and row corresponds to a point in the input vector qs.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#Base.length-Tuple{FEMBasis}","page":"FEM basis","title":"Base.length","text":"length(b::FEMBasis) -> Int\n\nReturn the number of basis functions represented by b.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.boundaries-Tuple{FEMBasis}","page":"FEM basis","title":"HelFEM.boundaries","text":"boundaries(b::FEMBasis)\n\nReturn an array of element boundaries as a sorted read-only array.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.nelements-Tuple{FEMBasis}","page":"FEM basis","title":"HelFEM.nelements","text":"nelements(b::FEMBasis)\n\nReturn the number of finite elements defining the basis.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.radial_integral-Tuple{FEMBasis,Any}","page":"FEM basis","title":"HelFEM.radial_integral","text":"radial_integral(b::FEMBasis, f; lderivative=false, rderivative=false) -> Matrix\n\nEvaluate the matrix elements of the function f in the basis\n\nf_ij = int_x_1^x_N+1 b^*_i(x) f(x) b_j(x)  dx\n\nf is expected to be a callable object that takes a single argument.\n\nIf the keyword arguments lderivative and rderivative, the derivative of the corresponding basis function is used instead.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#Internal-methods","page":"FEM basis","title":"Internal methods","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"These methods are not part of the public API, so they may change at any time.","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"HelFEM.nquad(::FEMBasis)\nHelFEM.elementrange(::FEMBasis, ::Integer)\nHelFEM.scale_to_element(::FEMBasis, ::Integer, ::Any)","category":"page"},{"location":"fembasis/#HelFEM.nquad-Tuple{FEMBasis}","page":"FEM basis","title":"HelFEM.nquad","text":"HelFEM.nquad(b::FEMBasis)\n\nReturn the number of quadrature points used when evaluating the matrix elements.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.elementrange-Tuple{FEMBasis,Integer}","page":"FEM basis","title":"HelFEM.elementrange","text":"elementrange(b::FEMBasis, k::Integer) -> (r_k, r_{k+1})\n\nReturns a tuple with the start and end boundary of the k-th element.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.scale_to_element-Tuple{FEMBasis,Integer,Any}","page":"FEM basis","title":"HelFEM.scale_to_element","text":"scale_to_element(b::RadialBasis, k::Integer, xs)\n\nScales the x values within the element k to the corresponding r coordinates.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"These utilities are not part of the public API.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"HelFEM.helfem\nHelFEM.chebyshev\nHelFEM.lobatto","category":"page"},{"location":"utilities/#HelFEM.helfem","page":"Utilities","title":"HelFEM.helfem","text":"CxxWrap wrapper module for the HelFEM shared library.\n\n\n\n\n\n","category":"module"},{"location":"utilities/#HelFEM.chebyshev","page":"Utilities","title":"HelFEM.chebyshev","text":"chebyshev(nquad) -> (xs::Vector, ws::Vector)\n\nReturn HelFEM's modified Gauss-Chebyshev quadrature points and weights for numerical integration of functions on x in -1 1.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#HelFEM.lobatto","page":"Utilities","title":"HelFEM.lobatto","text":"lobatto(nquad) -> (xs::Vector, ws::Vector)\n\nReturn HelFEM's Gauss-Lobatto quadrature points and weights for numerical on x in -1 1.\n\n\n\n\n\n","category":"function"},{"location":"radialbasis/#RadialBasis","page":"RadialBasis","title":"RadialBasis","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The helfem::atomic::basis::RadialBasis C++ class defines a set of basis functions b_n(r) on the domain r in 0 r_rmmax, where r_rmmax is a user-defined parameter. They are used to approximate functions on that domain via basis expansions","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"f(r) = sum_n c_n b_n(r)","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The basis consists of a set of polynomial functions repeated on consecutive sub-elements of the domain. Specifically, the N elements are defined by a sorted list of N+1 element boundaries at r_k, with r_0 = 0 and r_N = r_rmmax.","category":"page"},{"location":"radialbasis/#Polynomials-and-elements","page":"RadialBasis","title":"Polynomials and elements","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The polynomials p_i(x) are represented by instances of subclasses of helfem::atomic::polynomial_basis::PolynomialBasis, wrapped in Julia with PolynomialBasis, and they are defined on the domain x in -1 1. For each element, the x-axis is scaled and shifted to cover the element. That is, by using the midpoint r^(k)_rmmid and half-width r^(k)_lambda of the element of the k-th element","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"r^(k)_rmmid = fracr_k + r_k-12 quad\nr^(k)_lambda = fracr_k - r_k-12","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"the x and r coordinates for each element can be transformed into each other with","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"r = r^(k)_rmmid + x cdot r^(k)_lambda\nquadtextrmorquad\nx = left( r - r^(k)_rmmid right)  r^(k)_lambda","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"Note that this is valid and meaningful only within an element. Or in other words, you must always have x in -1 1 and k picked appropriately such that r in r_k-1 r_k.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"We also assume that the first and the last polynomial is non-zero at the element boundary, whereas the other polynomials vanish at the element boundaries.","category":"page"},{"location":"radialbasis/#Basis-functions","page":"RadialBasis","title":"Basis functions","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The basis function b_(ki), corresponding to the i-th polynomials in the k-th element, is defined by","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"b_(ki)(r) = p_i(r)  r\nquad\nforall r notin r_k-1 r_k  b_(ki)(r) = 0","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"That is, they are the basis polynomials in the element, scaled by 1r, and zero outside of the element.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"That is, almost. There are two additional things to consider:","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"Nodes at element boundaries. The polynomials are defined by nodes, and the edge nodes of each element are shared by two elements. For this reason, the basis functions that are non-zero at element boundaries r = r_k (corresponding to x = pm 1) are formally considered to be the same basis function, just spanning two elements. In other words, b_(k-1 M) and b_(k 1) (where M is the number of polynomials in each element) are glued together into a single function for k = 2 ldots N-1.\nBoundary conditions. In order to impose the boundary conditions r f(r) to 0 as r to 0 and f(r_rmmax) = 0, which come from the physical problem, the first function b_(11)(r) in the first element and the last function b_(NM)(r) in the last element are removed, since they would not obey the boundary conditions.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"Overall, this means that if you have N elements and M polynomials, you have N cdot M - (N-1) - 2 = N cdot (M - 1) - 1 basis functions.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"warning: TODO\nThis may not be entirely true â€“ it looks like you can have more than one overlapping function between elements? C.f. Nbf method of the RadialBasis class:size_t RadialBasis::Nbf() const {\n  // Number of basis functions is Nprim*Nel - (Nel-1)*noverlap - 1 - noverlap\n  return Nel() * (bf.n_cols - poly->get_noverlap()) - 1;\n}What's poly->get_noverlap()?","category":"page"},{"location":"radialbasis/#Matrix-elements","page":"RadialBasis","title":"Matrix elements","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The radial basis set also provides methods to evaluate matrix elements of various operators.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"A_ij = int_0^r_rmmax b^*_i(r) hatA b_j(r)  r^2 dr","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The inner product, by definition, has a weight function of w(r) = r^2.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The physical motivation for both the weight function and the 1r scaling of the basis polynomials comes from spherical symmetry, since we assume that we are solving spherically symmetric equations on mathbbR^3. The functions on mathbbR^3 are assumed to be represented using a radial function P(r) and spherical harmonics","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"Psi(vecx) = P(r) Y_ell m(thetavarphi)","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"and we will use the basis set to expand P(r). The integrals of spherically symmetric operators then get an r^2 weight from the angular integration when reduced down to a radial integral","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"int_mathbbR^3 Psi^*_1(vecx) hatA Psi_2(vecx) dV\n= delta_ell_1ell_2 delta_m_1 m_2 int_0^infty P^*_1(r) hatA P_2(r)  r^2 dr","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"By scaling the basis polynomials with 1r, we actually cancel out the weight function, and so the integrals for the matrix elements become just simple integrals over polynomials within an element","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"A_(ki)(kj) = int_r_k-1^r_k p_i(x(r)) hatA p_j(x(r))  r^2 dr","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"where x(r) takes care of the scaling between the x and r values for the element.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"When evaluating the matrix elements, HelFEM uses modified Gauss-Chebyshev quadrature. The number of quadrature points nquad needs to be defined by the user.","category":"page"},{"location":"radialbasis/#Examples","page":"RadialBasis","title":"Examples","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"using HelFEM, Plots\npb = HelFEM.PolynomialBasis(:lip, 4)\nxgrid = [0, 1, 2, 3]\nb = HelFEM.RadialBasis(pb, xgrid, 100)\n# Calculate points for plotting\nrs = range(minimum(xgrid), maximum(xgrid), length=501)\nbs = b(rs)\na = @animate for i in 1:length(b)\n    plot(layout=(2,1), size=(900, 700), legend=false,\n        ylabel = [raw\"$b(r)$\" raw\"$r~b(r)$\"]\n    )\n    plot!(rs, bs, c=:lightgray, subplot=1)\n    plot!(rs, bs[:,i], c=:black, subplot=1)\n    plot!(rs, bs .* rs, c=:lightgray, subplot=2)\n    plot!(rs, bs[:,i] .* rs, c=:black, subplot=2)\n    vline!([xgrid xgrid], ls=:dash, c=1)\nend\ngif(a, fps=1)","category":"page"},{"location":"radialbasis/#Reference","page":"RadialBasis","title":"Reference","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"RadialBasis","category":"page"},{"location":"radialbasis/#HelFEM.RadialBasis","page":"RadialBasis","title":"HelFEM.RadialBasis","text":"struct RadialBasis\n\nWrapper type for the helfem::atomic::basis::RadialBasis class, representing a finite element basis for radial functions on the domain r in 0 r_rmmax.\n\n\n\n\n\n","category":"type"},{"location":"#HelFEM.jl","page":"Overview","title":"HelFEM.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"HelFEM.jl is a Julia wrapper for the HelFEM finite element method library.","category":"page"}]
}
