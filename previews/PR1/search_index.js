var documenterSearchIndex = {"docs":
[{"location":"polynomial/#Polynomial-bases","page":"Polynomial bases","title":"Polynomial bases","text":"","category":"section"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"The HelFEM.PolynomialBasis type wraps the corresponding C++ class and defines a primitive polynomial basis –- a set of polynomials p_i(x) on the domain x in -1 1. In the finite element method, these are then repeated in each element.","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"Currently the library supports three types of polynomials:","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":":legendre: Legendre polynomials\n:hermite: Hermite polynomials\n:lip: Lagrange interpolating polynomials (with Gauss-Lobatto nodes)","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"Each primitive basis is defined by the number of nodes, which then determines the order of the polynomials and how many polynomials are there in the set.","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"using HelFEM, Plots\nxs = range(-1, 1, length=2001)\na = @animate for nnodes = 2:15\n    b1 = PolynomialBasis(:legendre, nnodes)\n    b2 = PolynomialBasis(:hermite, nnodes)\n    b3 = PolynomialBasis(:lip, nnodes)\n    plot(\n        plot(xs, b1(xs), label=false, title=\"Legendre, nnodes=$nnodes\"),\n        plot(xs, b2(xs), label=false, title=\"Hermite, nnodes=$nnodes\"),\n        plot(xs, b3(xs), label=false, title=\"LIP, nnodes=$nnodes\"),\n        layout = (3, 1), size=(800, 1000)\n    )\nend\ngif(a, fps=0.5)","category":"page"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"Various methods are available to work with the polynomial basis and for introspection (see the reference).","category":"page"},{"location":"polynomial/#Reference","page":"Polynomial bases","title":"Reference","text":"","category":"section"},{"location":"polynomial/","page":"Polynomial bases","title":"Polynomial bases","text":"PolynomialBasis\nlength(::PolynomialBasis)\nHelFEM.nnodes(::PolynomialBasis)","category":"page"},{"location":"polynomial/#HelFEM.PolynomialBasis","page":"Polynomial bases","title":"HelFEM.PolynomialBasis","text":"struct PolynomialBasis\n\nWrapper type for the helfem::atomic::polynomial_basis::PolynomialBasis class, representing a set of polynomials p_i(x) on a domain x in -1 1.\n\nConstructors\n\nPolynomialBasis(basis::Symbol, nnodes)\n\nConstructs a particular polynomial basis with a specific number of defining nodes. basis must be one of: :hermite, :legendre or :lip.\n\n\n\n\n\n","category":"type"},{"location":"polynomial/#Base.length-Tuple{PolynomialBasis}","page":"Polynomial bases","title":"Base.length","text":"length(pb::PolynomialBasis) -> Integer\n\nReturns the number of basis functions (polynomials) represented by the given polynomial basis.\n\n\n\n\n\n","category":"method"},{"location":"polynomial/#HelFEM.nnodes-Tuple{PolynomialBasis}","page":"Polynomial bases","title":"HelFEM.nnodes","text":"HelFEM.nnodes(pb::PolynomialBasis) -> Integer\n\nReturns the number of control nodes used to define the polynomial basis in the constructor.\n\n\n\n\n\n","category":"method"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"EditURL = \"https://github.com/mortenpi/HelFEM.jl/blob/master/examples/particleinabox.jl\"","category":"page"},{"location":"examples/particleinabox/#D-Particle-in-a-Box","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"","category":"section"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"This notebook demonstrates how to generically set up a simple eigenvalue calculation within the ContinuumArrays framework and then uses the HelFEM FEM basis to solve it.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"using LinearAlgebra\nusing Plots\nusing DataFrames, DataFramesMeta, StatsPlots\nusing ContinuumArrays\nusing HelFEM\nusing HelFEM.CompactFEMBasis: HelFEMBasis\nusing QuasiArrays: domain, AbstractQuasiMatrix","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The equation we use for this example is","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"fracd^2 fdx^2 = lambda f(x)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"with x in a b, i.e. under the boundary condition","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"f(a) = f(b) = 0","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The analytical eigenvalues and eigenfunctions of this problem are given by","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"lambda_n = - left(fracpi nb - aright)^2\nquadquad\nf_n(x) = sqrtfrac2b - a rmsinleft(\n  npi fracx - ab - a\nright)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"where n in mathbbZ^+.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"We define the following Julia functions to access the analytical values. The Basis object is only necessary for specifying the domain (i.e. a and b).","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"function λ(R::AbstractQuasiMatrix, n::Integer)\n    @assert size(R, 1) == ℵ₁\n    @assert n >= 1\n    a, b = extrema(domain(axes(R, 1)))\n    - ((π*n)/(b - a))^2\nend\n\nfunction f(R::AbstractQuasiMatrix, n::Integer, x)\n    @assert size(R, 1) == ℵ₁\n    @assert x ∈ axes(R, 1)\n    @assert n >= 1\n    a, b = extrema(domain(axes(R, 1)))\n    sqrt(2/(b-a)) * sin((x-a)*n*π/(b - a))\nend\nnothing # hide","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The following function solves this numerically with a ContinuumArrays Basis. It returns the eigenvectors and eigenvalues of the operator within the ContinuumArrays framework, only requiring a Basis object to be passed. The boundaries (i.e. the domain) are again defined by the Basis object.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"function solve_∇²(R::AbstractQuasiMatrix)\n    # We restrict R to AbstractQuasiMatrix, not Basis, because if you e.g. restrict a basis\n    # with R[:, 2:end-1] to impose boundary conditions, that will not return a Basis object,\n    # but it still a valid basis set.\n    @assert size(R, 1) == ℵ₁\n    # The boundary box is determined from the domain of the basis.\n    xmin, xmax = extrema(domain(axes(R, 1)))\n    # Construct the abstract derivative operators on [a, b].\n    D = Derivative(axes(R, 1))\n    # Solve the generalized eigenvalue problem, since the basis, in general, will not be\n    # orthonormal. R'R yields the overlap matrix and -R'D'D*R materializes the matrix\n    # corresponding to the second derivative operator (note: D² = -D'D).\n    L, S = collect(-(R'D'D*R)), collect(R'R)\n    e = eigen(L, S)\n    # Just a sanity check to make sure that all the calculated eigenvalues are negative,\n    # which we assume based on the analytical solution.\n    @assert all(<=(0), e.values)\n    return (\n        R = R,\n        a = xmin, b = xmax,\n        λ = reverse(e.values),\n        states = reverse(e.vectors, dims=2),\n    )\nend\nnothing # hide","category":"page"},{"location":"examples/particleinabox/#Helper-functions","page":"1D Particle in a Box","title":"Helper functions","text":"","category":"section"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Let's define a bunch of helper functions for plotting etc.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"# Plot the numerical and corresponding analytical solution for a given n\nfunction plot_cmp!(s, n; c=nothing, label=nothing, kwargs...)\n    a, b = extrema(domain(axes(s.R, 1)))\n    # Set of point where the plot the functions\n    xs = range(a, b, length=501)\n    # Evaluate the basis function at the x grid\n    B = s.R[xs, :]\n    # Extract the n-th state. We normalize the sign of the function to start with a\n    # positive derivative on the left edge. We're assuming that the first basis function is\n    # the left-most one and that it is positive.\n    v = s.states[:, n] * sign(s.states[1, n])\n    # We use the generalized eigenvalue solver, but the eigenvectors it produces are not\n    # normalized with respect to the inner product (that takes the overlap matrix into\n    # account). So we normalize the vector by hand.\n    v ./= sqrt(dot(v, s.R's.R, v))\n    # Default color and label, if not explicitly passed\n    isnothing(c) && (c = n)\n    isnothing(label) && (label = \"n = $n\")\n    # Plot the numerical solution to the eigenfunction\n    plot!(xs, B * v; c = c, ls=:solid, label=label, kwargs...)\n    # Evaluate and plot the corresponding analytic solution\n    plot!(xs, (x -> f(s.R, n, x)).(xs); c = c, ls=:dash, label=nothing, kwargs...)\nend\n\n# Plot the numerical and analytical solutions for a whole set of n values on a single plot\nfunction plot_cmp_ns(s, ns)\n    plot(legend = :bottomleft)\n    for n in ns\n        plot_cmp!(s, n)\n    end\n    plot!([], ls=:solid, c = :black, label = \"Numerical\")\n    plot!([], ls=:dash, c = :black, label = \"Analytic\")\nend\n\n# Turn a solution into a DataFrame\nfunction eigenvalue_dataframe(s)\n    ns = 1:length(s.λ)\n    df = DataFrame(\n        n = ns,\n        λ = s.λ,\n        # Ref is necessary because R is not declared a scalar in terms of broadcasting\n        λ_exact = λ.(Ref(s.R), ns),\n    )\n    return @transform(df, δ = :λ .- :λ_exact)\nend\nnothing # hide","category":"page"},{"location":"examples/particleinabox/#Example-solution","page":"1D Particle in a Box","title":"Example solution","text":"","category":"section"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Let's construct a very small basis (that's not going to be very good) and solve the equation in that basis.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"R = let a = -3, b = 5\n    pb = PolynomialBasis(:lip, 4)\n    b = FEMBasis(pb, [a, a + (b-a)*0.33, b])\n    HelFEMBasis(b)\nend\ns = solve_∇²(R)\nnothing # hide","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The solutions for the three lowest eigenvalues look like this.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"plot_cmp_ns(s, 1:3)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"For the higher n ones we see singular points at the element boundary.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"plot_cmp_ns(s, 4:5)\nvline!(boundaries(R.b), c = :gray, ls=:dash, lw=2, label=\"FEM boundaries\")","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The eigenvalues and their differences from the analytic values are","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Λ = eigenvalue_dataframe(s)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"And we can visualize the error, both on a linear and semi-log scale","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"plot(\n    @df(Λ, scatter(abs.(:δ))),\n    @df(Λ, scatter(abs.(:δ), yaxis=:log10)),\n    legend = false, xlabel = \"n\",\n    size = (900, 400)\n)","category":"page"},{"location":"examples/particleinabox/#Finer-basis","page":"1D Particle in a Box","title":"Finer basis","text":"","category":"section"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Let's now do the same exercise, but for a finer basis set.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"R = let a = -3, b = 5\n    pb = PolynomialBasis(:lip, 4)\n    b = FEMBasis(pb, range(a, b, length=31))\n    HelFEMBasis(b)\nend\ns = solve_∇²(R)\nnothing # hide","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Λ = eigenvalue_dataframe(s)\nΛ[1:5, :]","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"plot(\n    @df(Λ, scatter(abs.(:δ))),\n    @df(Λ, scatter(abs.(:δ), yaxis=:log10)),\n    legend = false, xlabel = \"n\",\n    size = (900, 400)\n)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The orbitals match the analytical solutions almost perfectly.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"plot_cmp_ns(s, 1:3)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Even at higher n values it is still quite fine.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"plot_cmp_ns(s, 30)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"For fun, let's look at the last 12 solution we get numerically and compare them to what we would expect to get analytically. As one would expect, the functions do not really match the analytical solutions.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"ps = [\n    plot_cmp_ns(s, lastindex(s.λ) - i)\n    for i = 0:(3*4) - 1\n]\nplot(ps..., layout=(4, 3), size = (900, 800))","category":"page"},{"location":"examples/particleinabox/#Convergence-of-eigenvalues","page":"1D Particle in a Box","title":"Convergence of eigenvalues","text":"","category":"section"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Here we calculate the eigenvalues for a set of different basis sets, increasing it in a systematic way (in this case, diving the interval into more and more elements).","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Λs = map(2 .^ (0:9)) do N\n    R = let a = -3, b = 5\n        pb = PolynomialBasis(:lip, 4)\n        b = FEMBasis(pb, range(a, b, length = round(Int, N) + 1))\n        HelFEMBasis(b)\n    end\n    s = solve_∇²(R)\n    df = eigenvalue_dataframe(s)\n    df[!, :N] .= N\n    df[!, :nb] .= size(R, 2)\n    return df\nend |> dfs -> vcat(dfs...)\ndescribe(Λs)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The errors of the eigenvalues converge systematically to the true value (or at least until they reach floating point roundoff errors).","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"@df @where(Λs, 1 .<= :n .<= 5) plot(\n    :N, abs.(:δ), group=:n,\n    yaxis=:log10, xaxis=:log10, m=:dot\n)\nxticks!(2 .^ (0:9), string.(2 .^ (0:8)))\nxlabel!(\"Number of FEM elements\")\nylabel!(\"Error of the n-th eigenvalue\")","category":"page"},{"location":"examples/particleinabox/#Linear-spline-basis","page":"1D Particle in a Box","title":"Linear spline basis","text":"","category":"section"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The ContinuumArrays package defines a simple basis of linear splines. So, to demonstrate that the solve_∇² function is independent of the basis set, let's use the linear splines to also solve the equation.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"The basis looks like a bunch of overlapping triangles.","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"B = let\n    B = Spline{1}(range(-3, 5, length=11))\n    # Impose Dirichlet-0 boundary conditions, i.e. f(a) = f(b) = 0\n    B[:, 2:end-1]\nend\n# Let's plot the basis functions\nlet\n    a, b = extrema(domain(axes(B, 1)))\n    xs = range(a, b, length=500)\n    b = B[xs, :]\n    plot(xs, b, legend=false)\nend","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"We can pass the basis into the solve_∇² function and it will yield a reasonable, even if a little jagged, solution for the lowest eigenfunctions","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"s = solve_∇²(B)\nplot_cmp_ns(s, 1:3)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Let's also see what the convergence looks like with linear splines:","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"Λs = map(2 .^ (1:12)) do N\n    R = let a = -3, b = 5\n        B = Spline{1}(range(a, b, length=N))\n        # Impose Dirichlet-0 boundary conditions, i.e. f(a) = f(b) = 0\n        B[:, 2:end-1]\n    end\n    s = solve_∇²(R)\n    df = eigenvalue_dataframe(s)\n    df[!, :N] .= N\n    df[!, :nb] .= size(R, 2)\n    return df\nend |> dfs -> vcat(dfs...)\ndescribe(Λs)","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"@df @where(Λs, 1 .<= :n .<= 5) plot(\n    :N, abs.(:δ), group=:n,\n    yaxis=:log10, xaxis=:log10, m=:dot\n)\nxticks!(2 .^ (0:12), string.(2 .^ (0:12)))\nxlabel!(\"Number linear splines\")\nylabel!(\"Error of the n-th eigenvalue\")","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"","category":"page"},{"location":"examples/particleinabox/","page":"1D Particle in a Box","title":"1D Particle in a Box","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fembasis/#Finite-element-basis","page":"FEM basis","title":"Finite element basis","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The FEMBasis type provides an alternative implementation of the finite element basis with slightly different conventions. Unlike RadialBasis, it does not scale the elements with 1r, so it can also span into negative x values.","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"It is also implemented directly in Julia, rather than wrapping a C++ class, although it still relies on the primitive polynomial bases from the HelFEM C++ library.)","category":"page"},{"location":"fembasis/#Elements,-polynomials-and-basis-functions","page":"FEM basis","title":"Elements, polynomials and basis functions","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The basis is defined as a set of polynomials (p_i(t); an instance of PolynomialBasis) that is repeated in each element. The elements are simply defined as a list of N+1 real values x_1  x_2  ldots  x_N+1.","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"Each polynomial is defined on the domain t in -1 1 and so for each element where x in x_i x_i+1, the transformation between the two coordinates is given by","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"x = x^(k)_rmmid + x^(k)_rmlambda t\niff\nt = fracx - x^(k)_rmmidx^(k)_rmlambda","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"where x^(k)_rmmid and x^(k)_rmlambda are the midpoint and width of the k-th element, respecively, defined by","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"x^(k)_rmmid = fracx_i+1 + x_i2\nquad\nx^(k)_rmlambda = fracx_i+1 - x_i2","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The basis functions b_i(x) are therefore just the original polynomials scaled to each element using that transformation. The only exception to that are the first and last polynomial in each element that are formally joined together into a single basis function that spans two elements. By definition, outside of the range x_1 x_N+1, the basis functions are assumed to be zero.","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The basis also drops the first polynomial in the first elements and the last polynomial in the last elements to impose the boundary conditions","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"b_i(x_1) = 0 quad b_i(x_N) = 0","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"using HelFEM, Plots\npb = PolynomialBasis(:lip, 4)\nxgrid = [-2, -0.5, 1.5, 3]\nb = FEMBasis(pb, xgrid)\n# Calculate points for plotting\nrs = range(minimum(xgrid), maximum(xgrid), length=501)\nbs = b(rs)\na = @animate for i in 1:length(b)\n    plot(size=(900, 350), legend=false, ylabel = [raw\"$b(r)$\" raw\"$r~b(r)$\"])\n    plot!(rs, bs, c=:lightgray)\n    plot!(rs, bs[:,i], c=:black)\n    vline!([xgrid xgrid], ls=:dash, c=1)\nend\ngif(a, fps=1)","category":"page"},{"location":"fembasis/#Matrix-elements","page":"FEM basis","title":"Matrix elements","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"The radial_integral method can be used to evaluate matrix elements of a function f(x) between the basis functions (or its derivatives)","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"f^(nm)_ij = int_x_1^x_N+1 b^(n)*_i(x) f(x) b^(m)_j(x)  dx","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"By default, the basis functions themselves are used (n = m = 0), but optionally it is also possible to substitute them with derivatives (i.e. n = 1 and/or m=1).","category":"page"},{"location":"fembasis/#Reference","page":"FEM basis","title":"Reference","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"FEMBasis\nFEMBasis(::Any) # corresponds to (::FEMBasis)(::Any)\nlength(::FEMBasis)\nboundaries(::FEMBasis)\nnelements(::FEMBasis)\nradial_integral(::FEMBasis, ::Any)","category":"page"},{"location":"fembasis/#HelFEM.FEMBasis","page":"FEM basis","title":"HelFEM.FEMBasis","text":"struct FEMBasis\n\nProvides a Julia-based implementation of a finite element basis, but using HelFEM-provided primitive polynomials. Unlike RadialBasis, it does not scale the basis functions with 1r, and is therefore valid for any x interval on mathbbR.\n\nConstructors\n\nFEMBasis(pb::PolynomialBasis, boundaries; [nquad])\n\nConstructs a FEM basis with elements defined by the boundaries specified by boundaries using the set of polynomials defined by pb as the primitive polynomials basis. Optionally, nquad can be specified to change the number of quadrature points used in the Gauss-Chebyshev quadrature when evaluating matrix elements.\n\n\n\n\n\n","category":"type"},{"location":"fembasis/#HelFEM.FEMBasis-Tuple{Any}","page":"FEM basis","title":"HelFEM.FEMBasis","text":"(b::FEMBasis)(qs; derivative=0) -> Matrix\n\nFunctor syntax to evaluate the basis functions at specified points. Returns a matrix where each column corresponds to a basis function and row corresponds to a point in the input vector qs.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#Base.length-Tuple{FEMBasis}","page":"FEM basis","title":"Base.length","text":"length(b::FEMBasis) -> Int\n\nReturn the number of basis functions represented by b.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.boundaries-Tuple{FEMBasis}","page":"FEM basis","title":"HelFEM.boundaries","text":"boundaries(b::FEMBasis)\n\nReturn an array of element boundaries as a sorted read-only array.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.nelements-Tuple{FEMBasis}","page":"FEM basis","title":"HelFEM.nelements","text":"nelements(b::FEMBasis)\n\nReturn the number of finite elements defining the basis.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.radial_integral-Tuple{FEMBasis,Any}","page":"FEM basis","title":"HelFEM.radial_integral","text":"radial_integral(b::FEMBasis, f; lderivative=false, rderivative=false) -> Matrix\n\nEvaluate the matrix elements of the function f in the basis\n\nf_ij = int_x_1^x_N+1 b^*_i(x) f(x) b_j(x)  dx\n\nf is expected to be a callable object that takes a single argument.\n\nIf the keyword arguments lderivative and rderivative, the derivative of the corresponding basis function is used instead.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#Internal-methods","page":"FEM basis","title":"Internal methods","text":"","category":"section"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"These methods are not part of the public API, so they may change at any time.","category":"page"},{"location":"fembasis/","page":"FEM basis","title":"FEM basis","text":"HelFEM.nquad(::FEMBasis)\nHelFEM.elementrange(::FEMBasis, ::Integer)\nHelFEM.scale_to_element(::FEMBasis, ::Integer, ::Any)","category":"page"},{"location":"fembasis/#HelFEM.nquad-Tuple{FEMBasis}","page":"FEM basis","title":"HelFEM.nquad","text":"HelFEM.nquad(b::FEMBasis)\n\nReturn the number of quadrature points used when evaluating the matrix elements.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.elementrange-Tuple{FEMBasis,Integer}","page":"FEM basis","title":"HelFEM.elementrange","text":"elementrange(b::FEMBasis, k::Integer) -> (r_k, r_{k+1})\n\nReturns a tuple with the start and end boundary of the k-th element.\n\n\n\n\n\n","category":"method"},{"location":"fembasis/#HelFEM.scale_to_element-Tuple{FEMBasis,Integer,Any}","page":"FEM basis","title":"HelFEM.scale_to_element","text":"scale_to_element(b::RadialBasis, k::Integer, xs)\n\nScales the x values within the element k to the corresponding r coordinates.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"These utilities are not part of the public API.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"HelFEM.helfem\nHelFEM.chebyshev\nHelFEM.lobatto","category":"page"},{"location":"utilities/#HelFEM.helfem","page":"Utilities","title":"HelFEM.helfem","text":"CxxWrap wrapper module for the HelFEM shared library.\n\n\n\n\n\n","category":"module"},{"location":"utilities/#HelFEM.chebyshev","page":"Utilities","title":"HelFEM.chebyshev","text":"chebyshev(nquad) -> (xs::Vector, ws::Vector)\n\nReturn HelFEM's modified Gauss-Chebyshev quadrature points and weights for numerical integration of functions on x in -1 1.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#HelFEM.lobatto","page":"Utilities","title":"HelFEM.lobatto","text":"lobatto(nquad) -> (xs::Vector, ws::Vector)\n\nReturn HelFEM's Gauss-Lobatto quadrature points and weights for numerical on x in -1 1.\n\n\n\n\n\n","category":"function"},{"location":"radialbasis/#RadialBasis","page":"RadialBasis","title":"RadialBasis","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The helfem::atomic::basis::RadialBasis C++ class defines a set of basis functions b_n(r) on the domain r in 0 r_rmmax, where r_rmmax is a user-defined parameter. They are used to approximate functions on that domain via basis expansions","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"f(r) = sum_n c_n b_n(r)","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The basis consists of a set of polynomial functions repeated on consecutive sub-elements of the domain. Specifically, the N elements are defined by a sorted list of N+1 element boundaries at r_k, with r_0 = 0 and r_N = r_rmmax.","category":"page"},{"location":"radialbasis/#Polynomials-and-elements","page":"RadialBasis","title":"Polynomials and elements","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The polynomials p_i(x) are represented by instances of subclasses of helfem::atomic::polynomial_basis::PolynomialBasis, wrapped in Julia with PolynomialBasis, and they are defined on the domain x in -1 1. For each element, the x-axis is scaled and shifted to cover the element. That is, by using the midpoint r^(k)_rmmid and half-width r^(k)_lambda of the element of the k-th element","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"r^(k)_rmmid = fracr_k + r_k-12 quad\nr^(k)_lambda = fracr_k - r_k-12","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"the x and r coordinates for each element can be transformed into each other with","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"r = r^(k)_rmmid + x cdot r^(k)_lambda\nquadtextrmorquad\nx = left( r - r^(k)_rmmid right)  r^(k)_lambda","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"Note that this is valid and meaningful only within an element. Or in other words, you must always have x in -1 1 and k picked appropriately such that r in r_k-1 r_k.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"We also assume that the first and the last polynomial is non-zero at the element boundary, whereas the other polynomials vanish at the element boundaries.","category":"page"},{"location":"radialbasis/#Basis-functions","page":"RadialBasis","title":"Basis functions","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The basis function b_(ki), corresponding to the i-th polynomials in the k-th element, is defined by","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"b_(ki)(r) = p_i(r)  r\nquad\nforall r notin r_k-1 r_k  b_(ki)(r) = 0","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"That is, they are the basis polynomials in the element, scaled by 1r, and zero outside of the element.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"That is, almost. There are two additional things to consider:","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"Nodes at element boundaries. The polynomials are defined by nodes, and the edge nodes of each element are shared by two elements. For this reason, the basis functions that are non-zero at element boundaries r = r_k (corresponding to x = pm 1) are formally considered to be the same basis function, just spanning two elements. In other words, b_(k-1 M) and b_(k 1) (where M is the number of polynomials in each element) are glued together into a single function for k = 2 ldots N-1.\nBoundary conditions. In order to impose the boundary conditions r f(r) to 0 as r to 0 and f(r_rmmax) = 0, which come from the physical problem, the first function b_(11)(r) in the first element and the last function b_(NM)(r) in the last element are removed, since they would not obey the boundary conditions.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"Overall, this means that if you have N elements and M polynomials, you have N cdot M - (N-1) - 2 = N cdot (M - 1) - 1 basis functions.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"warning: TODO\nThis may not be entirely true – it looks like you can have more than one overlapping function between elements? C.f. Nbf method of the RadialBasis class:size_t RadialBasis::Nbf() const {\n  // Number of basis functions is Nprim*Nel - (Nel-1)*noverlap - 1 - noverlap\n  return Nel() * (bf.n_cols - poly->get_noverlap()) - 1;\n}What's poly->get_noverlap()?","category":"page"},{"location":"radialbasis/#Matrix-elements","page":"RadialBasis","title":"Matrix elements","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The radial basis set also provides methods to evaluate matrix elements of various operators.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"A_ij = int_0^r_rmmax b^*_i(r) hatA b_j(r)  r^2 dr","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The inner product, by definition, has a weight function of w(r) = r^2.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"The physical motivation for both the weight function and the 1r scaling of the basis polynomials comes from spherical symmetry, since we assume that we are solving spherically symmetric equations on mathbbR^3. The functions on mathbbR^3 are assumed to be represented using a radial function P(r) and spherical harmonics","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"Psi(vecx) = P(r) Y_ell m(thetavarphi)","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"and we will use the basis set to expand P(r). The integrals of spherically symmetric operators then get an r^2 weight from the angular integration when reduced down to a radial integral","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"int_mathbbR^3 Psi^*_1(vecx) hatA Psi_2(vecx) dV\n= delta_ell_1ell_2 delta_m_1 m_2 int_0^infty P^*_1(r) hatA P_2(r)  r^2 dr","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"By scaling the basis polynomials with 1r, we actually cancel out the weight function, and so the integrals for the matrix elements become just simple integrals over polynomials within an element","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"A_(ki)(kj) = int_r_k-1^r_k p_i(x(r)) hatA p_j(x(r))  r^2 dr","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"where x(r) takes care of the scaling between the x and r values for the element.","category":"page"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"When evaluating the matrix elements, HelFEM uses modified Gauss-Chebyshev quadrature. The number of quadrature points nquad needs to be defined by the user.","category":"page"},{"location":"radialbasis/#Examples","page":"RadialBasis","title":"Examples","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"using HelFEM, Plots\npb = HelFEM.PolynomialBasis(:lip, 4)\nxgrid = [0, 1, 2, 3]\nb = HelFEM.RadialBasis(pb, xgrid, 100)\n# Calculate points for plotting\nrs = range(minimum(xgrid), maximum(xgrid), length=501)\nbs = b(rs)\na = @animate for i in 1:length(b)\n    plot(layout=(2,1), size=(900, 700), legend=false,\n        ylabel = [raw\"$b(r)$\" raw\"$r~b(r)$\"]\n    )\n    plot!(rs, bs, c=:lightgray, subplot=1)\n    plot!(rs, bs[:,i], c=:black, subplot=1)\n    plot!(rs, bs .* rs, c=:lightgray, subplot=2)\n    plot!(rs, bs[:,i] .* rs, c=:black, subplot=2)\n    vline!([xgrid xgrid], ls=:dash, c=1)\nend\ngif(a, fps=1)","category":"page"},{"location":"radialbasis/#Reference","page":"RadialBasis","title":"Reference","text":"","category":"section"},{"location":"radialbasis/","page":"RadialBasis","title":"RadialBasis","text":"RadialBasis","category":"page"},{"location":"radialbasis/#HelFEM.RadialBasis","page":"RadialBasis","title":"HelFEM.RadialBasis","text":"struct RadialBasis\n\nWrapper type for the helfem::atomic::basis::RadialBasis class, representing a finite element basis for radial functions on the domain r in 0 r_rmmax.\n\n\n\n\n\n","category":"type"},{"location":"#HelFEM.jl","page":"Overview","title":"HelFEM.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"HelFEM.jl is a Julia wrapper for the HelFEM finite element method library.","category":"page"}]
}
